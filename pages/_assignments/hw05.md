---
layout: assignment-two-column
title: "PhotoApp: Authentication"
abbreviation: HW5
type: homework
due_date: 2022-03-01
ordering: 5
draft: 1
points: 20
---

<style>
    table.cheatsheet th:first-child,
    table.cheatsheet td:first-child {
        min-width: 200px;
    }
    .compact li {
        margin-bottom: 4px;
        line-height: 1.5em;
    }
    table.rubric-indent th:first-child, table.rubric-indent td:first-child {
        min-width: 20px;
        width: 30px;
    }
    table.rubric-indent th:last-child, table.rubric-indent td:last-child {
        min-width: 100px;
        width: 100px;
    }
    table.rubric code {
        font-size: 1.1em;
        font-weight: bold;
    }
</style>

## 1. Introduction
In this homework assignment, you are going to lock down your system so that only logged in users can interact with it. This includes:

{:.compact}
1. Interacting with the API you built in HW3
2. Interacting with the user interface (UI) you built in HW4

To do this, we will be using JSON Web Tokens (JWTs). Please review the [Lecture 15](../lectures/lecture15) materials for the basic JWT workflow.

### Cookies versus authorization headers
As discussed in lecture, you can pass JWTs between the client and the server in a variety of different ways: through cookies, custom HTTP headers, the request body, and/or as query parameters. In this assignment, you will be using the JWT "cookie approach" to handle authentication from within your UI, and the JWT "HTTP Header approach" to handle authentication for your REST API.

#### The Cookie Approach
1. Your flask templates will rely on JWT cookies. You will write code to generate these cookies on the server. Subsequently, these cookies will sent back and forth between the browser and the server via request and response headers (respectively). 
2. The `flask-jwt-extended` library has a few convenience functions that will help you generate and set these cookies:

    {:.compact}
    * `create_access_token()` -- generates the token
    * `set_access_cookies()` -- sets the access cookies on the response header
3. Workflow:
    1. Create a login form that allows a user to post their username and password to a `/login` endpoint.
    2. If the username and password are valid, set the access token cookie and redirect them to home screen.
    3. With the cookie set, all protected resources that use the flask templates will know who is logged into the system.
    4. When the token expires, the system will redirect the user to the login screen.

#### The HTTP Header Approach
From now on, your REST API Endpoints will require a JWT token -- passed as either an Authorization header (external app) or an X-CSRF-TOKEN (internal app). To do this, you will implement the following functionality:
1. An API endpoint to request an access and refresh token
2. Security measures on all of your REST API endpoints that require an access token.
3. You will also modify the way your app determines the current user (we will no longer hardcode user #12 as the active user).
4. And finally, after you've locked down all of your API endpoints, you need to update the JavaScript you made in HW4 to include authentication information in the header.

Here is an example of how you might use fetch to access a protected resource from an ***external*** python app (or from Postman)...

```python
import requests

response = requests.get(
    'http://localhost:5000/api/posts',
    headers={
        'Authorization': 'Bearer ' + access_token
    }
)
print('Status Code:', response.status_code)
print(response.json())
```

...and here is an example of how you might use fetch to access a protected resource ***internally*** -- from within your flask app (like you did in HW4)...

```js
fetch("/api/posts", {
        method: "GET",
        headers: {
            'Content-Type': 'application/json',
            'X-CSRF-TOKEN': '5c4f034d-13d6-4aa2-b686-ee0add18426b'
        }
    })
    .then(response => response.json())
    .then(data => {
        console.log(data);
    });
```

You will create a new endpoints that allow a client to authenticate in order to receive a valid acces / refrehs token. You will also lockdown all of your endpoints so that all requests have included the JWT token in the header.


### Summary of Tasks

### flask-jwt-extended
To help you implement the JWT workflow, you will be using the `flask-jwt-extended` library, which offers some common JSON Web Token functionality that will help you. We have included a cheatsheet of some of this library's functionality. That said, please refer to the full documentation to get a more comprehensive explanation. Some links that we have found to be particularly helpful:

{:.compact}
* <a href="https://flask-jwt-extended.readthedocs.io/en/latest/options/#general-options" target="_blank">Configuration options</a>
* <a href="https://flask-jwt-extended.readthedocs.io/en/latest/api/#verify-tokens-in-request" target="_blank">Verification & helper functionality</a>
* <a href="https://flask-jwt-extended.readthedocs.io/en/latest/refreshing_tokens/" target="_blank">Refreshing tokens</a>

### flask-jwt-extended Cheatsheet
Below are some key pieces of functionality that will be important to you as you implement authentication:

{:.cheatsheet}
| Description | Code | Notes |
|--|--|--|--|
| **Configuration** | |  | |
| Access Token Expiration | `JWT_ACCESS_TOKEN_EXPIRES` | defaults to 10 minutes |
| Refresh Token Expiration | `JWT_REFRESH_TOKEN_EXPIRES`| defaults to 30 days
| Secret (Salt for encryption algo) | `JWT_SECRET_KEY` | store in your .env file, not in your codebase |
| **Methods & Properties** | | | |
| Current User | `flask_jwt_extended.current_user` | property that stores a User object of the logged in user. Only works if you configure your "user_lookup_loader" (see below)|
| |  | |
| **Decorators** | | | |
| Current User function decorator | `@jwt.user_lookup_loader` | Decorator to be used to specify how the current user should be retrieved (given the identity info embedded in the token). |


#### Server-Side Logic
Within Flask, you will implement the following functionality:
##### REST API
1. Create a "log in" endpoint that will issue a JWT token (`/api/token`).
2. Endpoint security: you will "lock down" all of your API endpoints except for `/api/token` so that they require a valid JWT.
3. You will deprecate the global `current_user` variable, and instead get the user from the JWT token each time you need to use it.

#### Client-Side Logic
1. Create a login form that will send the user's username and password credentials to the `/login` endpoint.
1. Store the resulting token in localStorage
1. Embed the header in all of your fetch requests so that you don't get security errors.

## 2. Setup
### 1. Install dependencies:

```bash
# (using whatever approach you have found to work for installing dependencies
pip3 install flask-jwt-extended
```

Also add this line to your `requirements.txt` so that when you deploy your app to Heroku, it will also install the dependency on the Heroku container instance:

```bash
Flask-JWT-Extended==4.3.1
```

### 2. Bugfix to `populate.py`
```python
user.set_password(password) # For me, it's line 63
```
Then run populate to rebuild your database...

### 3. Verify
Copy the tests into your tests folder and run them...

If you see this message, the tests passed!

## 3. Your Tasks

### 1. REST API Tasks

<table class="rubric">
    <thead>
        <tr>
            <th>Method/Route</th>
            <th>Description</th>
            <th>Parameters</th>
            <th>Points</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>POST /api/token</td>
            <td>Issues an access and refresh token based on the credentials posted to the API Endpoint.</td>
            <td>
                <ul>
                    <li><code>username</code> (string, required): The username of the person logging in.</li>
                    <li><code>password</code> (string, required): The password of the person logging in.</li>
                </ul>
            </td>
            <td></td>
        </tr>
        <tr>
            <td>POST /api/token/refresh</td>
            <td>Issues new access token if a valid refresh token is posted to the endpoint.</td>
            <td>
                <ul>
                    <li><code>refresh_token</code> (string, required): The refresh token that was previously issued to the user from the /api/token endpoint.</li>
                </ul>
            </td>
            <td></td>
        </tr>
        <tr>
            <td>All routes</td>
            <td>Lockdown all endpoints. Every API endpoint in the system should now require a JWT token. Hint: use the <code>@jwt_required()</code> decorator from the flask-jwt-extended library.</td>
            <td></td>
            <td></td>
        </tr>
        <tr>
            <td>All routes</td>
            <td>Ensure that all tests pass with the new test suite.</td>
            <td></td>
            <td></td>
        </tr>
    </tbody>
</table>

### Other Flask Endpoints
1. Create login form for UI
2. If login successful, set JWT cookie and redirect to /
3. Create logout endpoint that unsets JWT cookies and redirects to /login
4. Lockdown the API tester UI /api so that 

<table class="rubric-indent">
    <thead>
        <tr>
            <th>Task</th>
            <th>Description</th>
            <th>Points</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <th colspan="2">Create login form for UI</th>
            <th>10 points</th>
        </tr>
        <tr>
            <td></td>
            <td>
                Create an HTML login form for your app (feel free to borrow code from the Lecture 15 files) by editing the <code>templates/login.html</code> html file.
            </td>
            <td>5</td>
        </tr>
        <tr>
            <td></td>
            <td>
                If the user posts a valid username and password, set the JWT cookie in the response header and redirect the user to the home screen.
            </td>
            <td>5</td>
        </tr>
        <tr>
            <td></td>
            <td>
                If the user does not post a valid username and password, redisplay the form with an appropriate error message.
            </td>
            <td>5</td>
        </tr>
        <tr>
            <td></td>
            <td>
                Ensure that the form is accessible by using the Wave Chrome extension.
            </td>
            <td></td>
        </tr>
        <tr>
            <th colspan="2">Lockdown your UI Endpoints</th>
            <th>2 points</th>
        <tr>
            <td></td>
            <td>
                Create a custom decorator on your <code>/</code> and <code>/api</code> endpoints:
                <ul>
                    <li>If the user is logged in (i.e. a JWT cookie is present), allow them to access the page.</li>
                    <li>If the user is not logged in, redirect them to the login page.</li>
                </ul>
            </td>
            <td></td>
        </tr>
        </tr>
    </tbody>
</table>

### Client tasks
1. Update all fetch endpoints from HW4 to use the X-CSRF header token. See static/api.js for an example.
