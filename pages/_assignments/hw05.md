---
layout: assignment-two-column
title: "PhotoApp: Authentication"
abbreviation: HW5
type: homework
due_date: 2022-03-08
ordering: 5
draft: 1
points: 30
---

<style>
    table.cheatsheet th:first-child,
    table.cheatsheet td:first-child {
        min-width: 200px;
    }
    .compact li {
        margin-bottom: 4px;
        line-height: 1.5em;
    }
    table.rubric-indent th:first-child, table.rubric-indent td:first-child {
        min-width: 20px;
        width: 30px;
    }
    table.rubric-indent th:last-child, table.rubric-indent td:last-child {
        min-width: 100px;
        width: 100px;
    }
    table.rubric code, table.rubric-indent code {
        font-size: 1.1em;
        font-weight: bold;
    }
    table.rubric pre {
        font-size: 1.1em;
        /* font-weight: 600; */
        background: #F3F3F3;
        padding: 5px;
        border-radius: 5px;
    }
</style>

## 1. Introduction
In this homework assignment, you are going to lock down your system so that only logged in users can interact with it. This includes:

{:.compact}
1. Interacting with the API you built in HW3
2. Interacting with the user interface (UI) you built in HW4

To do this, we will be using JSON Web Tokens (JWTs). Please review the [Lecture 15](../lectures/lecture15) materials for the basic JWT workflow.

### 1. Cookies versus authorization headers
As discussed in lecture, you can pass JWTs between the client and the server in a variety of different ways: through cookies, custom HTTP headers, the request body, and/or as query parameters. In this assignment, you will be using the JWT "cookie approach" to handle authentication from within your UI, and the JWT "HTTP Header approach" to handle authentication for your REST API.

#### The Cookie Approach (for Browser-Based Interactions)
1. Your Flask UI will rely on JWT cookies. You will write code to generate these cookies on the server. Subsequently, these cookies will sent back and forth between the browser and the server via request and response headers (respectively). 
2. The `flask-jwt-extended` library has a few convenience functions that will help you generate and set these cookies:

    {:.compact}
    * `create_access_token()` -- generates the token
    * `set_access_cookies()` -- sets the access cookies on the response header
3. Workflow:

    {:.compact}
    * User sends username and password to the server via a login form.
    * If the credentials are valid, the server sets the JWT tokens using cookies.
    * Because the JWT cookies are set, the system will know who is logged in.
    * When the JWT access token expires, the system redirects the user to the login screen.

#### The HTTP Header Approach (for the REST API)
In the case of the REST API, your client may or may not be your Flask application. For instance, in HW3, the Python test suite and Postman were ***external clients***. But in HW4, the client was your `hw4.js` file, which *was* part of your UI.

##### Browser Clients
For internal clients that use your REST API, you need to embed something called an `X-CSRF-TOKEN` in the header of your fetch requests. Here is an example of how you might use fetch to access a protected REST Endpoint from within your UI (like you did in HW4):

```js
fetch("/api/posts", {
        method: "GET",
        headers: {
            'Content-Type': 'application/json',
            'X-CSRF-TOKEN': '5c4f034d-13d6-4aa2-b686-ee0add18426b'
        }
    })
    .then(response => response.json())
    .then(data => {
        console.log(data);
    });
```

##### Non-Browser Clients
For external clients, you need to offer them another way to access your REST API without actually having to log into your UI. To do this, you will implement:

{:.compact}
* A way for a user to authenticate with the REST API order to receive an access and refresh token.
* Security measures on all of your REST API endpoints that require an access token.

Here is an example of how you might use fetch to access a protected resource from an ***external*** python app (or from Postman), using an access token:

```python
import requests

response = requests.get(
    'http://localhost:5000/api/posts',
    headers={
        'Authorization': 'Bearer ' + access_token
    }
)
print('Status Code:', response.status_code)
print(response.json())
```


### 2. The Flask-JWT-Extended Library
To help you implement the JWT workflow, you will be using the `flask-jwt-extended` library, which offers some common JSON Web Token functionality that will help you. We have included a cheatsheet of some of this library's functionality. That said, please refer to the full documentation to get a more comprehensive explanation. Some links that we have found to be particularly helpful:

{:.compact}
* <a href="https://flask-jwt-extended.readthedocs.io/en/latest/options/#general-options" target="_blank">Configuration options</a>
* <a href="https://flask-jwt-extended.readthedocs.io/en/latest/api/#verify-tokens-in-request" target="_blank">Verification & helper functionality</a>
* <a href="https://flask-jwt-extended.readthedocs.io/en/latest/refreshing_tokens/" target="_blank">Refreshing tokens</a>

#### Cheatsheet
Below are some key pieces of functionality that will be important to you as you implement authentication:

{:.cheatsheet}
| Description | Code | Notes |
|--|--|--|--|
| **Configuration** | |  | |
| Access Token Expiration | `JWT_ACCESS_TOKEN_EXPIRES` | defaults to 10 minutes |
| Refresh Token Expiration | `JWT_REFRESH_TOKEN_EXPIRES`| defaults to 30 days
| Secret (Salt for encryption algo) | `JWT_SECRET_KEY` | store in your .env file, not in your codebase |
| **Methods & Properties** | | | |
| Current User | `flask_jwt_extended.current_user` | property that stores a User object of the logged in user. Only works if you configure your "user_lookup_loader" (see below)|
| |  | |
| **Decorators** | | | |
| Current User function decorator | `@jwt.user_lookup_loader` | Decorator to be used to specify how the current user should be retrieved (given the identity info embedded in the token). |


## 2. Setup
### 1. Install dependencies:

```bash
# (using whatever approach you have found to work for installing dependencies
pip3 install flask-jwt-extended
```

Also add this line to your `requirements.txt` so that when you deploy your app to Heroku, it will also install the dependency on the Heroku container instance:

```bash
Flask-JWT-Extended==4.3.1
```

### 2. Bugfix to `populate.py`
```python
user.set_password(password) # For me, it's line 63
```
Then run populate to rebuild your database...

### 3. Verify
Copy the tests into your tests folder and run them...

If you see this message, the tests passed!

## 3. Your Tasks
For this assignment, you will be implementing an authentication system for your REST API and for your app. Please complete the following tasks.

### TODO
1. You will also modify the way your app determines the current user (we will no longer hardcode user #12 as the active user).
1. And finally, after you've locked down all of your API endpoints, you need to update the JavaScript you made in HW4 to include authentication information in the header.

{:#rest}
### 1. REST API Tasks (15 Points)
You will make the following changes to your REST API in order to implement JWT authentication:

{:.compact}
1. Create an endpoint to issue a access / refresh token.
2. Create an endpoint to issue a new access token (using your refresh token).
3. Lock down all of your endpoints.

<table class="rubric">
    <thead>
        <tr>
            <th>Method/Route</th>
            <th>Description</th>
            <th>Parameters</th>
            <th>Points</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>POST /api/token</td>
            <td>Issues an access and refresh token based on the credentials posted to the API Endpoint.<br><br>Example (truncated for readability):
            <pre>{
    "access_token": "e0e.dsc.3NI6Ij",
    "refresh_token": "e0e.mcm.6ktQ"
}</pre>
            </td>
            <td>
                <ul>
                    <li><code>username</code> (string, required): The username of the person logging in.</li>
                    <li><code>password</code> (string, required): The password of the person logging in.</li>
                </ul>
            </td>
            <td>5</td>
        </tr>
        <tr>
            <td>POST /api/token/refresh</td>
            <td>
                Issues new access token if a valid refresh token is posted to the endpoint.<br><br>Example (truncated for readability):
                <pre>{
    "access_token": "e0e.Ras.i3NyZ"
}</pre>
            </td>
            <td>
                <ul>
                    <li><code>refresh_token</code> (string, required): The refresh token that was previously issued to the user from the /api/token endpoint.</li>
                </ul>
            </td>
            <td>5</td>
        </tr>
        <tr>
            <td>All routes</td>
            <td>
                Lockdown all endpoints. Every API endpoint in the system should now require a JWT token. Hint: use the <code>@jwt_required()</code> decorator from the flask-jwt-extended library. Ensure that all tests pass with the new test suite.
            </td>
            <td></td>
            <td>5</td>
        </tr>
    </tbody>
</table>

{:#ui}
### 2. User Interface Related Tasks (15 Points)
In addition to implementing JWTs within your REST API, you will also make modifications to your Flask UI. Specifically, you will:

{:.compact}
1. Implement a way to log into the system
2. Implement a way to log out of the system
3. Restrict access to the Home and API Tester screens to only people who are logged in.
4. Update your JavaScript fetch requests (from HW4) so that they use the `X-CSRF header token`.

<table class="rubric-indent">
    <thead>
        <tr>
            <th>Task</th>
            <th>Description</th>
            <th>Points</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <th colspan="2">1. Create login form for UI</th>
            <th>7 points</th>
        </tr>
        <tr>
            <td></td>
            <td>
                Create an HTML login form for your app (feel free to borrow code from the Lecture 15 files) by editing the <code>templates/login.html</code> html file. The form should POST to the <code>/login</code> endpoint.
            </td>
            <td>2</td>
        </tr>
        <tr>
            <td></td>
            <td>
                Implement the <code>/login</code> POST endpoint by editing <code>views/authentication.py</code>. If the enpoint receives a valid <code>username</code> and <code>password</code>, it should set the JWT cookie in the response header and redirect the user to the home screen (<code>/</code>).
            </td>
            <td>2</td>
        </tr>
        <tr>
            <td></td>
            <td>
                If the <code>/login</code> POST endpoint does not receive a valid username and password, redisplay the form with an appropriate error message.
            </td>
            <td>2</td>
        </tr>
        <tr>
            <td></td>
            <td>
                Ensure that the form is accessible by using the Wave Chrome extension.
            </td>
            <td>1</td>
        </tr>
        <tr>
            <th colspan="2">2. Create logout form for UI</th>
            <th>3 points</th>
        </tr>
        <tr>
            <td></td>
            <td>
                Create logout endpoint (GET) by editing <code>views/authentication.py</code>. This endpoint should unset the JWT cookies and redirect the user to the <code>/login</code> page.
            </td>
            <td>3</td>
        </tr>
        <tr>
            <th colspan="2">3. Lockdown your UI Endpoints</th>
            <th>3 points</th>
        </tr>
        <tr>
            <td></td>
            <td>
                Create a custom decorator on your <code>/</code> and <code>/api</code> endpoints:
                <ul class="compact">
                    <li>If the user is logged in (i.e. a JWT cookie is present), allow them to access the page.</li>
                    <li>If the user is not logged in, redirect them to the login page.</li>
                </ul>
            </td>
            <td>3</td>
        </tr>
        <tr>
            <th colspan="2">4. Modify your JavaScript fetch statements</th>
            <th>3 points</th>
        </tr>
        <tr>
            <td></td>
            <td>
                Update your JavaScript fetch requests (from HW4) so that they use the <code>X-CSRF header token</code>. Otherwise, your POST, DELETE, and PATCH requests will be rejected by your API. For an example of how to do this, please see <code>static/js/api.js</code>.
            </td>
            <td>3</td>
        </tr>
    </tbody>
</table>

## 4. What to Turn In
Please review the requirements above and ensure you have met them. Specifically:

{:.medium}
| Points | Category |
|--|--|
| [15 points](#rest)  | REST API Tasks |
| [15 points](#ui) | User Interface Related Tasks |


### Canvas Submission
When you're done, please submit the following to Canvas:

{:.checkbox-list}
* A zip file of your code
* A comment that includes the following:
    * A link to your Heroku app
    * Your responses to the accessibility questions
    * The name of your partner (if applicable)
    * A description of the extra credit you did (if applicable).
